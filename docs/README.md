# HTML

## 谈一谈元素属性 href 和 src 的区别？

##### 字面区别

##### href

Hypertext Reference  
 超文本 &nbsp;&nbsp;引用或参照

##### src

Source 资源

_英文字面上看来，好像是差不多意思_

    <img src="smile.png">
    <a href="smile.png">笑一下</a>

这段代码带来的区别是什么呢？

- img 会直接把图片渲染在页面上，src 引用的资源直接成为了当前文档的一部分，因为它把资源下载了下来并绑定在文档上，浏览器遇到这个属性会先下载这个资源并编译，执行完了之后才会进行下一步  
  就像汽车加油，加完了才能走
  <br>

- 而 a 标签不会渲染图片，需要点击 a 标签，才能在另一个地址看到图片  
  href 建立了一个通道，这个通道联系着其他资源

##### 主要使用场景

#### href

- link
- a

#### src

- img
- style
- script
- input
- iframe

<br>

> href 建立超链接，通过通道联系引用资源  
> src 会把资源下载下来，代替当前元素，嵌入到文档中

---

## 什么是标签语义化

##### 为什么要使用语义化标签？

我用 DIV+CSS 也能做出来一样的效果，确实单纯看效果两者并没有什么区别

但是页面不止是给人看的，机器也要看爬虫也要看，网页结构更清晰方便开发维护

#### 语义化标签有什么好处？

- 签语义化有助于构架良好的 HTML 结构，有利于搜索引擎的建立索引、抓取  
  简单来说，试想在 H1 标签中匹配到的关键词和在 div 中匹配到的关键词搜索引擎会吧那个结果放在面。
- 利于不同设备的解析（屏幕阅读器，盲人阅读器等）满是 div 的页面这些设备如何区分那些是主要内容优先阅读？
- 利于构建清晰的机构，有利于团队的开发、维护

##### 写语义化代码应该注意什么？

- 尽可能少的使用无语义的标签 div 和 span；在语义不明显时，既可以使用 div 或者 p 时，尽量用 p, 因为 p 在默认情况下有上下间距，对兼容特殊终端有利
- 不要使用纯样式标签，如：b、font、u 等，改用 css 设置  
  需要强调的文本，可以包含在 strong 或者 em 标签中（浏览器预设样式，能用 CSS 指定就不用他们）strong 默认样式是加粗（不要用 b），em 是斜体（不用 i）
- 使用表格时，标题要用 caption，表头用 thead，主体部分用 tbody 包围，尾部用 tfoot 包围  
  表头和一般单元格要区分开，表头用 th，单元格用 td
- 表单域要用 fieldset 标签包起来，并用 legend 标签说明表单的用途  
  每个 input 标签对应的说明文本都需要使用 label 标签，并且通过为 input 设置 id 属性  
   在 lable 标签中设置 for= someld 来让说明文本和相对应的 input 关联起来

##### 那么常见的语义化标签有哪些呢？

- `<h1>`~`<h6>` ，作为标题使用，并且依据重要性递减
- `<p>`段落标记，不要再使用 <br /> 来换行了
- `<ul>`、`<ol>`、`<li>`、`<ul>`无序列表
- `<dl>`、`<dt>`、`<dd>`、`<dl>` 就是“定义列表”
- `<em>`、`<strong>`、`<em>`是用作强调、`<strong>` 是用作重点强调
- `<table>`、`<thead>`、`<tbody>`、`<td>`、`<th>`、`<caption>` 就是用来做表格不要用来布局

##### HTML5 新增了哪些语义化标签？

![av](/images/HTML5tag.png)

---

## doctype 的作用

在开始学习前端之前，你总会需要创建一个 HTML

<br>

_在 HTML 标签之前，还有一个你可能不会注意到的 <!DOCTYPE> 标记。虽然它不显眼，但我们需要知道它为什么存在_

HTML 文件中，<!DOCTYPE>是必须的，需要放到整个文档的顶部  
格式为 `<!DOCTYPE html>` ，它存在的意义在于阻止浏览器在渲染文档时进入混杂模式(Quirks Mode)

<br>

也就是说 `<!DOCTYPE html>` 这一文档类型可以确保浏览器尽可能地使用遵循规范的模式来渲染  
而不是使用某些不符合规范的渲染模式

##### 混杂模式和标准模式

很久很久以前，web 页面主要运行在两类浏览器：网景的 Navigator 和微软的 IE

<br>

后来 W3C 制定了 web 规范之后，为了保证现有页面可用，各大浏览器不能立马使用新规范

<br>

于是，浏览器厂商们引入了两种模式来区别对待符合新标准的站点和旧的遗留站点：混杂模式（Quirks Mode）和标准模式 （Standards Mode）

在过渡阶段还存在一种接近标准模式（Almost Standards Mode）

- 混杂模式，也成为怪异模式，会兼容 Navigator 4 和 IE 5 的非标准行为
- 近标准模式会兼容少数的混杂行为，可以理解为过渡模式
- 标准模式只兼容符合标准描述的行为

##### 标准类型下的 “怪异” 行为

我们应该都遇到过这个问题  
div 里面如果装着一个 img，div 就会被无故撑高几个像素

<br>

这的确非常奇怪  
其实这个现象只有标准模式才会有

> 近标准模式和标准模式之间的唯一区别在于是否对 img 元素给定行高(line-height)和基线(baseline)

_这一现象虽然怪异，但也是标准对于文本对齐的一种规范处理_

<br>

由于标准模式指定了默认的 baseline 对齐方式导致了这一问题  
所以想要解决也很简单，给 img 标签指定 vertical-align: middle 即可

---

## 块级标签都有哪些？

# CSS

## 伪类和伪元素有什么区别？

## 为什么要清除浮动？如何清除？

## 不同选择器的权重怎么算的

## 前端几大经典布局的实现方案？

## toB 和 toC 的区别

## 移动端布局的几大方案？

#### 1、media（主流)

适合 Pc 端移动端用一套项目  
像京东这种，pc 端移动端是不一样的，那就不适合用这种

#### 2、rem（主流)

针对移动端有单独设计

#### 3、flex

部分布局可以用 flex

#### 4、vh/vw

通过调整视口百分比，跟百分比类似，也称为百分比布局

---

## css 的 display 可以取什么值？

## 用 ts 实现一个数组的去重

## 手写 promise 的实现

## flex 布局和传统布局的区别

## http 各种状态码的含义

## 什么时候用 flex ？除了这种方式居中还能用什么？响应式布局还能怎么做？盒子模型？

## opacity 兼容处理？

> 上面的操作也已经实现的 VSCODE 远程开发的基础步骤

## 介绍一下 postion 属性

---

## CSS 中 link 和 import 的区别

- link 属于 HTML 标签，@import 是 CSS 提供的
- 页面被加载的时候 link 就会被加载，而 @import 需要等到页面加载完才会加载
- import 只能在 IE5 以上使用，link 是 HTML 标签，无兼容问题
- link 的权重高于 @import

---

## filter 还能做哪些事？

通过添加源可以加快软件下载，同时更多的源也提供更丰富的软件

如果下载速度可以就不用配置了

---

## 盒子水平垂直居中的方案？

这个问题在项目中很常见，开始我用的什么。。<br>
后来 css3 出现，我尝试用什么。。。<br>
后来我在博客上看到了还有什么什么技术。。于是尝试使用。。<br>

---

<strong>记住一共有五中方案</strong>

- 定位三种
- display：flex
- javascript
- display：table-cell

###### 哈哈

<strong> 定位

---

## 不同选择器的权重怎么算的

---

## 说一说盒模型吧

可以认为每个 html 标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着  
这就是所谓的盒模型

#### 盒模型分为 IE 盒模型和 W3C 标准盒模型

- ##### W3C 标准盒模型

属性 width,height 只包含内容 content，不包含 border 和 padding

- ##### IE 盒模型

属性 width,height 包含 border 和 padding，指的是 content+padding+border

> 在 ie8+浏览器中使用哪个盒模型可以由 box-sizing(CSS 新增的属性)控制，默认值为 content-box，即标准盒模型

> 如果将 box-sizing 设为 border-box 则用的是 IE 盒模型  
> 如果在 ie6,7,8 中 DOCTYPE 缺失会触发 IE 模式

盒子的大小为 content+padding+border 即内容的(width)+内边距的再加上边框，而不是加上 margin

<br>

> css 的盒模型由 content(内容)、padding(内边距)、border(边框)、margin(外边距)组成

但盒子的大小由 content+padding+border 这几部分决定，把 margin 算进去的那是盒子占据的位置，而不是盒子的大小！

<br>

我们在编写页面代码时应尽量使用标准的 W3C 模型（需在页面中声明 DOCTYPE 类型），这样可以避免多个浏览器对同一页面的不兼容。

<br>

因为若不声明 DOCTYPE 类型，IE 浏览器会将盒子模型解释为 IE 盒子模型，FireFox 等会将其解释为 W3C 盒子模型

<br>

若在页面中声明了 DOCTYPE 类型，所有的浏览器都会把盒模型解释为 W3C 盒模型

---

## position 和 float 的区别？

## CSS 怎么画出一个三角形

## 旋转动画怎么做？

---

## rem 和 em 的区别

##### 区别

- rem:基于 html 元素字体大小
- em：根据使用它的元素大小决定（其实不是根据父元素，是因为继承了父元素，所以造成误解）

##### 深刻理解

> 他们都是灵活可以扩展的单位  
> 你使用 1rem 或者 1em ，其实都可以被浏览器翻译成 16px-160px 以及其他任何值

浏览器使用 px，那 1px 就显示为 1px

- rem：如果默认根元素字体为 16px，那你的 10rem 就会渲染成 160px
- em：如果一个 div 有 18px 字体大小，那此时你的元素 10em 就是 180px

浏览器默认虽然是 16px，但是浏览器的这个默认参数，用户是可以自己改变的
它支持 9-72px 之间的任何值！！

> html 根元素 继承的就是 浏览器设置的字体大小！除非重写一个具体单位来覆盖
> 所以表面上 rem 根据的是 html 根元素的字体大小，但实际可能是来自浏览器的设置大小

如果我们使用 rem，请确保无论用户如何设置自己的浏览器，我们都要显示正常

---

# JavaScript

## 复制一个数组有哪些方法？哪个方法最好

## cdn 的作用和原理？

## 响应式的浏览器原理？

## async await 原理？

## 正则表达式的使用程度

## 了解 ES6 中的 Set 和 Map 吗？

https://juejin.im/post/5ee71e92f265da76f65329fe

---

## 说一下原型链吧（proto，prototype）

先来说一下构造函数

##### 构造函数

> 每个构造函数(constructor)都有一个原型对象(prototype)  
> 原型对象都包含一个指向构造函数的指针, 而实例(instance)都包含一个指向原型对象的内部指针.

_看一个例子_

<br>

<img src="/images//constor1.png">

person1 和 person2 都是 Person 的实例  
这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person 即：

    console.log(person1.constructor == Person) //true
    console.log(person2.constructor == Person) //true

### prototype

每个构造函数都有一个 prototype 属性，指向调用该构造函数而创建的实例的原型  
也就是这个例子中的 person1 和 person2 的原型

<img src="/images//constor2.png">

### proto

这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫 proto  
这个属性会指向该对象的原型

    function Person() {}
    var person1 = new Person()
    console.log(person1.__proto__ === Person.prototype) // true

### constructor

每个原型都有一个 constructor 属性指向关联的构造函数

    function Person() {}
    var person1 = new Person()
    console.log(Person === Person.prototype.constructor) // true
    console.log(person1.__proto__ === Person.prototype) // true

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性  
如果还查不到，就去找原型的原型，一直找到最顶层为止

> 这个查找的过程，就叫做原型链

---

## 了解 vue-lazyloader 吗

---

## 如何判断一个类型是数组？instanceOf 实现？

---

https://juejin.im/post/5b0b9b9051882515773ae714

## 提交表单有哪些常用方法？应用层通信层发生了哪些过程？

---

## let、const 及 var 的区别？

> 这个问题，涉及到变量提升

    console.log(a);  // undefined
    var a = 1;

上述代码就是一个变量提升  
 在声明变量之前，我们就可以使用它

这段代码可以翻译为：

    var a
    console.log(a)
    a = 10

好了，不仅变量可以提升  
 函数也会提升

    console.log(a)  // f a(){}
    function a(){}
    var a = 1

看了上面两个例子，我们差不多知道 var 存在的问题了  
接下来我们来看 let 和 const

    var a = 1
    let b = 1
    const c = 1
    console.log(window.b)  //undefined
    console.log(window.c)  //undefined

    function test(){
      console.log(a)
      let a
    }
    test()

我们发现，使用了 let 和 const 后  
变量不会被挂载到 window 上
这就和 var 有了明显的区别

---

## 关于内存泄漏

---

## 解构赋值和拓展运算符

## Set/Map 数据结构

---

## null 和 undefined 有什么区别

- undefined 声明了变量，但没有赋值，它存在，但没有值
- null 没有值，根本就不存在，没有任何可读的东西  
  <br>


    var a ;

声明了，但没有赋值，此时 a 就是 undefined

   <br>

##### 用 typeof 判断类型，会看到两者的区别

    typeof(null)  //object
    typeof(undefined)  //undefined

##### 和数字相加的区别

- undefined + 数字 = NaN
- null + 数字 = 数字

---

## 事件委托是什么？主要解决什么问题？

http://www.zhangyunling.com/564.html

---

## 了解基本的数据类型吗

https://juejin.im/post/5e23eae9f265da3e2a79230c

##### 先了解一下为什么需要数据类型？

计算机中，不同数据占据的存储空间是不同的  
为了充分利用空间，需要定义不同数据类型

> 简单类型又叫基本数据类型，或者值类型  
> 复杂类型又叫做引用类型

当我们声明一个变量时

    var x = "变量"

实际是在内存空间中开辟了一块地方来存储这个数据  
但是我们调用这个变量的时候不能靠输入十六位进制来取值吧，太麻烦了  
所以起了一个变量名，实际就是在引用内存地址

#### String

单引号或双引号
<br><br>

#### Number

常规包含：

- 浮点类、整数
- 二进制
- 十六进制

三个特殊值：

- Infinity，无穷大，大于任何值
- -Infinity，无穷小，小于任何值
- NaN，非数值
  <br><br>

#### Boolean

有两个值

- true == 1
- false == 0

javascript 中任何值都可以转换为布尔值。

<br><br>

#### Undefined

变量没有赋值时的默认值

<br>

#### Null

---

## 对 Promise 的理解

## 移动端的触摸事件了解吗

## 对 ES6 的理解

## Interator 迭代器

## 一般怎么判断基本的数据类型

https://juejin.im/post/5b0554c86fb9a07acb3d3ddc

## 普通函数和构造函数的区别

## 深拷贝一个数组怎么做

## async / await 及实现原理

https://juejin.im/post/5a9516885188257a6b061d72

## 了解 return 吗？

## AJAX 核心四步操作？交互过程？

## 底层运行机制：微任务宏任务和事件循环机制

## Generator 生成器函数

## 手写懒加载函数

## 怎么理解防抖和节流的

https://juejin.im/post/5dc3716cf265da4d417652ff

## JS 底层运行机制：单线程和同步异步编程

## 了解作用域吗？怎么预防作用域污染

https://juejin.im/post/5e264f7d51882520c02c8f3e

## 闭包怎么理解？项目中用到过吗

https://juejin.im/post/5e264f7d51882520c02c8f3e

---

## 为什么 0.1 + 0.2 != 0.3

我们都知道计算机是通过二进制来存储东西的，那么 0.1 在二进制中会表示为

    // (0011) 表示循环
    0.1 = 2^-4 \* 1.10011(0011)

我们可以发现，0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002

    0.100000000000000002 === 0.1 // true

那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002

    0.200000000000000002 === 0.2 // true

所以这两者相加不等于 0.3 而是 0.300000000000000004

    0.1 + 0.2 === 0.30000000000000004 // true

_那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？_

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

    console.log(0.100000000000000002) // 0.1

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

    parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true

---

## 堆栈内存的理解

---

## 箭头函数和普通函数的区别

https://juejin.im/post/5c76972af265da2dc4538b64

- 箭头函数更加简洁
- 箭头函数是不存在 this，它的 this 继承的是函数上下文中的 this

---

## 说一下拷贝对象吧，深拷贝浅拷贝

https://juejin.im/post/5ad5b908f265da23870f540d

## fetch 基础和实战

## 谈一谈变量提升？

## json 的数据格式都介绍一下

## JS 是否了解过函数式编程

---

## 讲一下存储方案 cookie、webStorage、session 等

### Cookie 是什么？

Cookie 算是比较古老的技术了

了解 http 的同学，肯定知道，http 是一个不保存状态的协议  
什么叫不保存状态，就是一个服务器是不清楚是不是同一个浏览器在访问他

<br>

在 cookie 之前，有另外的技术是可以解决，这里简单讲一下  
就是在请求中插入一个 token，然后在发送请求的时候，把这个东西带给服务器  
这种方式是易出错，所以有了 cookie 的出现

<br>

#### cookie 是什么

cookie 就是一种浏览器管理状态的一个文件，它有 name，也有 value  
后面那些看不见的是 Domain、path 等等

![av](/images/cookie.png)

#### Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

#### 那 Session 又是什么呢？

Session 代表着服务器和客户端一次会话的过程

<br>

Session 对象存储特定用户会话所需的属性及配置信息  
这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去

<br>

当客户端关闭会话，或者 Session 超时失效时会话结束

#### Cookie 和 Session 有什么不同？

- ###### 作用范围不同
  Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- ###### 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型
  一般情况下我们可以在 Session 中保持一些常用变- 量信息，比如说 UserId 等。
- ###### 有效期不同
  Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 - Session 超时都会失效。
- ###### 隐私策略不同
  Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃- 取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- ###### 存储大小不同
  单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie

#### 那为什么需要 Cookie 和 Session，他们有什么关联？

说起来为什么需要 Cookie ，这就需要从浏览器开始说起

<br>

我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道

<br>

这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作  
那这套机制的实现就需要 Cookie 和 Session 的配合

![av](/images/session.png)

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session  
请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名

<br>

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息

<br>

如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息

<br>

如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作

<br>

_根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁  
大部分系统也是根据此原理来验证用户登录状态_

#### 浏览器禁止了 cookie 该怎么办呢？

_既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转？_

<br>

第一种方案，每次请求中都携带一个 SessionID 的参数  
也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456...

<br>

第二种方案，Token 机制

<br>

Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理

<br>

Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似

<br>

当用户第一次登录后，服务器根据提交的用户信息生成一个 Token  
响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证

#### 如何考虑分布式 Session 问题？

_在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求  
那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题_

- Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配  
  这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。

* Session 复制  
  任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。

- 共享 Session  
  服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致

一般建议采用第三种方案

---

HTML5 离线存储

---

## 跨域怎么处理？都知道什么方法？ jsonp 和 cors 哪个更安全

说起跨域请求，必须要了解浏览器的同源策略

<br>

同源策略/SOP（Same origin policy）是一种约定

由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击

<br>

所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源

#### 解决跨域请求的常用方法是：

- 通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。
- 通过 Jsonp 跨域
- 其它跨域解决方案

#### 重点谈一下 Jsonp 跨域原理

浏览器的同源策略把跨域请求都禁止了，但是页面中的 script、 img、iframe 标签是例外，不受同源策略限制

_Jsonp 就是利用 script 标签跨域特性进行跨域数据访问_

<br>

JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript

在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递

<br>

当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了

JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求

---

## 异步的处理方式？都是怎么处理的

#### 我们都知道，JS 是单线程运行的

每个 window 就是一个 JS 线程

JS 的三大异步来源：用户交互、IO、定时器

<br>

但是，浏览器确不是单线程的

例如 Web kit 引擎，可能有如下线程：

- JavaScript 引擎线程
- 界面渲染线程
- 浏览器事件触发线程
- HTTP 请求线程


    setTimeout(()=>{
      console.log(111)
    },500);

这段代码的 111 会在什么时候输出？
是 500ms 时打印吗？

<br>

> 错，是在 500ms 或 500ms 以后某个时段

当一个异步事件发生的时候，它就进入事件队列

浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询事件队列并处理事件

<br>

比如，浏览器当前正在忙于处理 onclick 事件，这时 window onSize 事件发生了，这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件

首先对于异步事件，我们在执行到这行代码的时候会进行一个注册
将你要在未来某个时间段要执行的函数注册一下，放在 Event table 中。这个 Event table 中可以有很多事件

<br>

比如你一次发了好多 ajax 请求，那么他们就全部注册了

在未来的时间到了，就会把注册的事件放入 Event queue（任务队列）这个任务队列就是马上要执行的内容

<br>

任务队列什么时候可以执行？
在主线程的 call stack 为空的时候，会把任务队列的第一个事件放入 call stack 中执行

<br>

这里面涉及一个 queue（队列）的特点就是先进先出

<br>

_在注册后先放入 Event queue 的事件就会更早的离开 Event queue 进入主线程执行_

这个时候是不是觉得自己明白点了？ 唉别高兴的太早了

#### 接下来我们聊一聊宏任务和微任务

##### 常见的宏任务

- setTimeout
- setInterval

##### 常见的微任务

- promise
- process.nextTick

#### 它们的执行规则？

首先在 call stack（执行栈） 中的内容执行完毕清空后  
会在 Event queue 检查一下哪些是宏任务哪些是微任务，然后执行所有的微任务  
然后再执行一个宏任务，之后再次执行所有的微任务

<br>

也就是说在主线程任务执行完毕后会把任务队列中的微任务全部执行，然后再执行一个宏任务

<br>

这个宏任务执行完再次检查队列内部的微任务，有就全部执行没有就再执行一个宏任务

#### 几种已知的异步解决方案

- 回调函数(callback)
- 事件监听(发布/订阅)解析
- Promise 解析及从 0 ～ 1 的源码体验
- Generator 全面解析
- Async/Await 解析

- ##### 回调函数（callback）

简单理解就是一个函数被作为参数传递给另一个函数

_回调并不一定就是异步，并没有直接关系，只不过回调函数是异步的一种解决方案_

<br>

假定有两个函数 f1 和 f2，后者等待前者的执行结果

    f1();
    f2();

如果 f1 是一个很耗时的任务，这么一直等下去，浏览器可能会因此失去响应

<br>

所以我们可以考虑把 f2 写成 f1 的回调函数

![av](/images/callback1.png)

采用这种方式，我们把同步操作变成了异步操作  
f1 不会堵塞程序运行

<br>

回调函数的优点是简单、容易理解和部署

但是如果需要多次异步调用，而且它们之间的数据还有着依赖关系
这过深的嵌套，那么恐怖的回调地狱就出现了

<br>

这非常不利于代码的阅读和维护

    doSomethingAsync1(function(){
        doSomethingAsync2(function(){
            doSomethingAsync3(function(){
                doSomethingAsync4(function(){
                    doSomethingAsync5(function(){
                        // code...
                    });
                });
            });
        });
    });

##### 事件监听（发布订阅模式）

任务的执行不取决于代码的顺序，而取决于某个事件是否发生

<br>

还是以 f1 和 f2 为例，首先，为 f1 绑定一个事件（这里采用的 jQuery 的写法）

    f1.on('done', f2);

上面这行代码的意思是，当 f1 发生 done 事件，就执行 f2。然后，对 f1 进行改写：

![av](/images/fabudingyue.png)

这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"，有利于实现模块化

缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰

#### Promises 对象

ES2015 (ES6)标准化和引入了 Promise 对象，它是异步编程的一种解决方案

简单来说就是用同步的方式写异步的代码，可用来解决回调问题

##### Promise 使用

Promise 是一个构造函数，我们可以通过 new 关键字来创建一个 Promise 实例

也可以直接使用 Promise 的一些静态方法

![av](/images/promise.png)

new Promise 创建了一个 promise 实例，Promise 构造函数会把一个叫做处理器函数(executor function)的函数作为它的参数

<br>

处理器函数接收两个参数分别是 resolve 和 reject  
这两个参数也是两个回调函数

- resolve 函数在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- reject 函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

简单理解就是一个是成功回调，一个是失败回调

https://juejin.im/post/5e4613b36fb9a07ccc45e339

https://juejin.im/post/5a8fe8a05188255efc5f6c94

https://juejin.im/post/599ff3d5f265da24843e6276

###### 基本用法

![av](/images/promise1.png)

---

# Vue

---

## 为什么使用 vue 框架而不是使用其他框架？

- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；
  <br>

- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；
  <br>

- 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
  <br>

- 虚拟 DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言，vue 存在很大的优势。

---

## vuex 是什么？怎么使用？哪种功能场景使用？

vue 框架中状态管理。在 main.js 引入 store，注入

新建了一个目录 store.js，….. export

场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

#### vuex 的属性

- state：基本数据（数据源存放地）
- getters：从基本数据派生出来的数据
- mutations：提交更改数据的方法，同步！
- actions：像一个装饰器，包裹 mutations，使之可以异步。
- modules：模块化 Vuex

---

## Vue 和 Vuex 的差异？

## Vue 设计原则的理解？

## vue 从 data 改变到页面渲染的过程

## 如果没有 vue-router，你们还会做单页面应用吗

## Vuex 的触发过程 （actions，state，view）？

## 关于 VUE 的性能优化

## 双向绑定原理？

## 组件的设计原则

## 对 flutter 的了解

## 讲一下 vue 有哪些特性

## 谈谈对 Vue 组件化的理解

---

## vue 中 key 的作用？说说对它的理解

这是用来标记 DOM 元素的，区分不同的相同 DOM  
从而提升性能

> 从原则上来讲，最好都加上 Key

通常情况下，我们都会将 key 绑定为 id
如果数组中没有 id 属性，怎么办呢？
使用索引 —— index

    <li v-for="item in fruits" :key="index"></li>

---

## 对 Vue 源码了解吗

## VUE 的性能优化

## 对 Vue3.0 的新特性有没有了解？

---

## vue 里的虚拟 dom 是怎么回事

##### 所有的浏览器渲染引擎工作流程大致分为 5 步

- 第一步，构建 DOM 树：  
  用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；
- 第二步，生成样式表：  
  用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；
- 第三步，构建 Render 树：  
  将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对- 象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；
- 第四步，确定节点坐标：  
  根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；
- 第五步，绘制页面：  
  根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来

###### 这里需要注意的是：

- 1、DOM 树的构建是文档加载完成开始的？  
  构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成- 之后才开始构建 render 树和布局。
- 2、Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？  
  这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。
- 3、CSS 的解析注意点？  
  CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。
- 4、JS 操作真实 DOM 的代价？  
  用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程  
   在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行 10 次

  例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功  
  计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验

### 那虚拟 DOM 到底有什么好处？

> ​ 虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的

<br>

如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量

<br>

所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上  
操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制

##### 所谓的 Virtual DOM 算法。包括几个步骤：

- 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
- 当状态变更的时候，重新构造一棵新的对象树
- 然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上  
  视图就更新了

##### 算法主要是实现上面步骤的三个函数：element，diff，patch

    // 1. 构建虚拟 DOM
    var tree = el('div', {'id': 'container'}, [
    	el('h1', {style: 'color: blue'}, ['simple virtal dom']),
    	el('p', ['Hello, virtual-dom']),
    	el('ul', [el('li')])
    ])

    // 2. 通过虚拟 DOM 构建真正的 DOM
    var root = tree.render()
    document.body.appendChild(root)

    // 3. 生成新的虚拟 DOM
    var newTree = el('div', {'id': 'container'}, [
    	el('h1', {style: 'color: red'}, ['simple virtal dom']),
    	el('p', ['Hello, virtual-dom']),
    	el('ul', [el('li'), el('li')])
    ])

    // 4. 比较两棵虚拟 DOM 树的不同
    var patches = diff(tree, newTree)

    // 5. 在真正的 DOM 元素上应用变更
    patch(root, patches)

<br>

_当然这是非常粗糙的实践，实际中还需要处理事件监听等_

---

## vue 的生命周期讲一下

### 1、beforeCreate

这一步，是开始创建实例化，你拿不到任何实例里面的东西  
包括 data 、methods、监听等

> 实例里的任何东西，任何，你都，拿不到！

### 2、created

实例创建完成了！  
这个阶段可以调用 methods 中的方法，或者操作 data 中的数据了

> 这一步就是最早拿到数据和方法的地方了

### 3、beforeMount

执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的

> 前两部操作里，你无论如何都是拿不到真实 dom 的  
> 想拿到 dom 元素就去 mounted 里

### 4、mounted

此阶段，Vue 实例已经初始化完成  
组件脱离了创建阶段，进入运行阶段  
可以操作 DOM 元素了，但也只能拿初始化时候的 dom 元素

> 如果存在异步操作把 dom 更改了，那你还是拿不到
> 只能去 updated 里找啦

### 5、beforeUpdate

当执行这个钩子时，页面中的显示的数据还是旧的，data 中的数据是更新后的， 页面还没有和最新的数据保持同步

### 6、updated

这次能拿到更新后的数据了

> 但是注意：
> update 只要相关数据更改一次就会执行一次
> （mounted 后改过一次数据都会执行这个）

所以不要在当前的钩子里修改组件中的 data 数据  
否则会触发 beforeUpdate、updated 两个钩子

_那样就进入了死循环！！！！无解了！！_

<br>
这里引申一下：

- updated 对所有数据变化进行统一处理
- watch 对具体某个数据变化做处理
- nextTick 对某个数据的某次变化做处理

### 7、beforeDestroy

实例进入销毁阶段，此时，实例仍可使用  
所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁

### 8、destroyed

_*Boom！*_  
实例销毁了，么得了  
里面所有的东西，都！没！了！！

##### created 和 mounted 的区别

- created 在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图
- mounted 在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。

#### 总结一下：

生命周期看起来是 8 个环节  
其实按照功能性来分，就是 4 个步骤：

- 实例创建前后 create
- 挂载 dom 前后 mount
- 更新数据前后 update
- 销毁实例前后 destroy

---

## Vue 的设计思路有了解吗

<!-- --------------------------------------------------- -->

# 计算机和浏览器原理

## 如何保证浏览器不受脚本的恶意攻击

---

## 浏览器渲染页面的过程

了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径

但是具体问题具体对待，所以没有标准的方案

#### 浏览器渲染页面的过程

从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：

- DNS 查询
- TCP 连接
- HTTP 请求即响应
- 服务器响应
- 客户端渲染

而这最后一步客户端渲染，又可以分为以下五个步骤：

- 处理 HTML 标记并构建 DOM 树。
- 处理 CSS 标记并构建 CSSOM 树。
- 将 DOM 与 CSSOM 合并成一个渲染树。
- 根据渲染树来布局，以计算每个节点的几何信息。
- 将各个节点绘制到屏幕上。

_需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。  
实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。_

#### 阻塞渲染：CSS 与 JavaScript

谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。  
例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

同时还要注意：

- 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
- JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性

_存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建_

- 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行
- JavaScript 可以查询和修改 DOM 与 CSSOM
- CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪

所以，script 标签的位置很重要

实际开发中，我们应该遵循下面两条：

- CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源
- JavaScript 应尽量少影响 DOM 的构建

#### 关于 CSS 阻塞

    <style> p { color: red; }</style>
    <link rel="stylesheet" href="index.css">

这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源  
浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕

#### 关于 JavaScript 阻塞

JavaScript 的情况比 CSS 要更复杂一些

    <p>为了卡兹莫丹！</p>
    <script>console.log("inline")</script>
    <p>为了暴风城！！</p>
    <script src="app.js"></script>
    <p>为了希尔瓦娜斯的荣耀！</p>

这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script  
上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打断一次（加载并且执行的时间段内）

---

<!-- -------------------------------------------------------- -->

# 网络协议

---

## 浏览器输入 URL 到整个页面渲染出来经历的过程详细讲解一下

## http 和 https 有什么区别？比如性能方面

先来简单了解一下计算机通信原理

### TCP/IP

互联网的关键技术就是 TCP/IP 协议  
两台计算机之间的通信是通过 TCP/IP 协议在因特网上进行的。实际上这个是两个协议：

- TCP: Transmission Control Protocol 传输控制协议
- IP: Internet Protocol 网际协议

#### TCP: 应用程序之间的通信

当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求  
这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路  
TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组

_TCP/IP 就是 TCP 和 IP 两个协议在一起协同工作，有上下层次的关系_

TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信

#### IP: 计算机之间的通信

IP 协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个 IP.用来在 internet 上标识这台计算机。 IP 负责在因特网上发送和接收数据包  
通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地

IP 协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）  
 为了提供消息检验功能，直接在 IP 协议上设计了传输控制协议 TCP

现在回头来看看 http 和 https

### HTTP 超文本传输协议

_是一种详细规定客户端与 web 服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议_

<br>

### HTTP 的特点

- ##### 无状态

每个请求结束后都会被关闭，每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况  
 <br>
服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器，就像是“人生只如初见”，比如说用户需要请求某个数据，需要登录权限，用户登录之后进行请求，结果因为 http 的无状态，等用户下一次还想请求一份数据，还需要再次登录，这样不就很烦了吗，所以就需要 session 和 cookie 来进行状态管理了

 <br>

- ##### 明文传输（未经过加密的报文）

因为，按 TCP/IP 协议族的工作机制，通信内容并不加密
所以有可能遭遇窃听风险

 <br>

- ##### 不验证通信方的身份

此举可能遭遇伪装  
也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题

<br>

任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应

带来的缺陷是显而易见的

- 无法确定对方，web 服务器就有可能伪装，客户端同样可能伪装
- 无法确定正在通信的对方是否具有访问权限
- 无法判定请求是来自何方、出自谁手
- 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击

##### 无法证明报文的完整性

在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉  
换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请 求 / 响应是前后相同的

<br>

_比如你在手机上打开应用内的网页时，有时会看到网页底部弹出了广告  
这实际上就说明你的 HTTP 内容被窃听、并篡改了_

> HTTP 存在这么多致命缺陷，那 HTTPS 能解决吗？

### HTTPS

Hyper Text Transfer Protocol Secure

相比 http，多了一个 secure，也就是 TLS（SSL），一个安全套接层

> TLS/SSL 全称安全传输层协议 Transport Layer Security  
> 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议  
> 所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造

<br>

https 和 http 都属于应用层（application layer），基于 TCP（以及 UDP）协议，但使用的端口不同。  
TCP 用的 port 是 80，https 用的是 443

> 注意：HTTPS 并非是应用层的一种新协议

只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已

通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP

> 简单点说就是：HTTP + 认证 + 加密 + 完整性保护 = HTTPS

好了，HTTPS 很强  
它解决了主机客户端的信任问题  
也防止了通信过程中数据的泄漏和篡改，更不用担心密匙被攻击者盗走

##### 那 HTTPS 足够安全吗？

但总的来说对于绝大部分人来说 HTTPS 还是相对安全的，至少比 HTTP 安全

> 世界上没有绝对的安全  
> 比如 2014 年的 Heartbleed 漏洞席卷全球，很多网站受到 heartbleed 威胁，其中就有雅虎，stackoverflow 这样的网站。

那既然这样，我们一直使用 HTTPS 就好了  
当然，HTTPS 也会存在一些问题

- 因为使用了 SSL，网络负载可能会慢 2-100 倍  
  因为除去 TCP 连接 、发送 HTTP 请求响应外，还要进行 SSL 通信
- SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强  
  针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。
- 因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少  
  因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信
- 想要节约购买证书的开销也是原因之一  
  要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买，功能越强大的证书费用也就会越高

---

## http 的请求头都包括哪些？

一个 HTTP 请求报文是由三部分组成

- 请求行
- 请求头
- 请求体

如果我们打开 chrom ，打开 network 就能看到结果
不过 chrom 给我们展示的是分析后的结果

要想看原始结果，需要点击
Request Headers 的 view source

- ### 请求行


    GET /index.html HTTP/1.1

这是一个请求行，一般包括：

- 请求方法
- URL 地址
- HTTP 协议版本字段

- ### 请求头

- Referer：表示请求从哪个 url 跳过来的
- Accept：告诉服务端，该请求支持的响应数据类型
- Cokkie：传递 cookie 属性
- User-Agent：用户标识，告知服务器客户端浏览器与操作系统信息
- Connection：连接类型，Keep-Alive 表示持久和服务端连接，close 表示已关闭
- Host：请求的服务器主机名
- Content-lenght：请求体长度
- Accept-Encoding：浏览器通知服务器，浏览器支持的数据压缩格式。如 GZIP 压缩
- Accept-Language：浏览器通知服务器，浏览器支持的语言。各国语言(国际化 i18n)
- Cache-Control：指定请求和响应遵循的缓存机制

---

## http 各种状态码的含义

- ### 2XX（Success 成功状态码）

- #### 200 OK

![av](/images/http200.png)

- #### 204 No Content

<!-- <img src="/images/http204.png" width="50%"> -->

![av](/images/http204.png)

- #### 206 Partial Content

  ![av](/images/http206.png)

- ### 3XX（Redirection 重定向状态码）

- #### 301 Moved Permanently

  ![av](/images/http301.png)

- #### 302 Found 临时重定向

该状态码表示请求的资源已被分配了新的 URL，希望用户(本次)能使用新的 URL 访问

<br>

和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的  
换句话说，已移动的资源对应的 URL 将来还有可能发生改变  
比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URL

- #### 303 See Other

  ![av](/images/http302.png)

  该状态码表示由于请求对应的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源

https://juejin.im/post/5a276865f265da432c23b8d2

- #### 304 Not Modified

打开一个经常访问的网站，看看 Network 传输的静态资源，很多都是 304 状态码，这些表示已经被浏览器缓存了，不需要重新请求服务器

<br>

_你要的资源跟以前一样，直接用以前的吧，我不用再新给你发了_

---

## OSI 七层协议？

你一定有疑问，前端知道这个有什么用，平时基本用不上不是么？  
这个倒是事实，我们平时一般只接触应用层的 HTTP 协议， 底层的协议我们可以毫不关
心。

<br>

但有些场景还是需要一些底层知识的。比如前端一般优化有一条原则是，尽量少发请求，那么为何少发请求就能优化加载，它的开销到底是什么？

<br>

又比如最近产品希望 uv 打点同一计算机唯一，但很可能用户会采用不同客户端使用该产品，研发该如何啪啪啪打产品脸。仔细思考一下，其实不少情景也需要一点底层知识，因而不要书到用时方恨少啊~

<img src="./images/osi7.png">

发送方从最高层开始，从上到下按顺序传输数据，每一层接收到由上层处理的数据时，添加该层的首部并可能会对数据进行处理（如表示层）。

<br>

而接收端则将顺序反过来，从首层开始，将数据的内容与该层对应的首部拆开，传给上一层。看起来很绕对吧？

<br>

简单理解可以这样，想象 A 将要寄一个易碎品寄给 B，A 所在的快递站寄件时有由七个人组成的打包流程，每个人只管接收上一个人的打包好的物件，并在外面套一个大一点盒子，传给下一个人。当物件寄到 B 所在的快递站时，同样也有七个人负责拆盒子，每个人只拆一个，最后将物件给到 B 手上。这样是不是简单易懂了？

<br>

_我们从上往下看_

#### 应用层

> 作为前端，应用层肯定是最熟悉的。它的作用是为应用程序提供服务并规定应用程序中通讯相关的细节，也就是为应用提供服务。  
> 常见的协议有 HTTP，FTP，TELNET、SMTP 等

我们日常开发中，接触的协议主要以 HTTP 为主，那么把浏览器看作一个应用，当用户发起请求时，通过 HTTP 协议获得数据以供浏览器使用，这就是应用层的用途。

而请求时发生错误，对错误进行处理，也是应用层需要负责的。

<br>

这一层可以想象成快递公司的收件员，当客户（应用）打电话（发起请求）给收件员（应用层）时，  
收件员可以根据用户的不同需求提供不同的服务（不同协议），比如隔天送达、指定时间送达等等。

#### 表示层

> 表示层的作用是将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。  
> 它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 ASCII、SSL/TLS 等。

作用看起来可能比较绕，但其实是挺好理解的。我只会说中文，而日本友人只会说日文，那么我们两个是无法交流的。  
但如果我们都会说英文，交流时我先在心里想好要说的话是什么，再用英语说出来，日本友人听到英文，在心里转换为日语，他就能弄懂我的意思，此时表示层就是各自在心里转化语言。

<br>

而浏览器请求回一堆数据，是解析成文本还是图片，就由表示层决定。数据的压缩、加密、打包等功能也都在这层完成。
这一层相当于快递公司的打包员。如果快递（数据）太臃肿，他会在不破坏快递的情况下压扁（压缩）它。

<br>

如果客户注重安全线，全能的快递公司还能用密码箱（ SSL/TLS）打包快递再快送。当然，打包员会确定，目的地快递站的拆包员，能无损地拆开包裹，将快递交给用户。

#### 会话层

> 会话层作用是负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。  
> 常见的协议有 ADSP、RPC 等

会话层可看作是快递公司的调度员。他管理着这次快递的相关的信息。

<br>

例如这次客户要发 100 吨沙土（数据），发到哪，到底是一车一车发、还是用轮船一次运过去。  
这些都是他的职责。而运完之后，相关信息（连接）也可以被销毁了，这也是调度员的职责。

#### 传输层

> 传输层起着可靠传输的作用。只在通信双方节点进行处理，而不需在路由器上处理。  
> 此层有两个具有代表性的协议： TCP 与 UDP

TCP 协议提供可靠的通信传输，简单说就是确认目标能通信的情况下才会传输数据（因此需要三次握手），传输过程如果丢了数据，也会重发。  
而 UDP 协议则不然，不会确认目标能否通信，只会根据协议发到对方地址的端口。至于对方收不收到，丢不丢包，一概不管。

<br>

传输层有一个重要作用，就是指定通信端口。  
以请求服务器数据为例，服务器有处理多种协议的能力，如之前应用层所说的 HTTP，FTP，TELNET 等，但到底你是用什么协议呢？  
服务器并不知道。

<br>

但如果你指定了端口，如 80，服务器就会知道你是想用 HTTP 协议的，自然会转给对应协议的处理程序进行处理。
作比喻的话，可以将传输层看作是快递公司的跟单员。负责任的跟单员（使用 TCP 协议）会保证快递送到客户手上，如果送不到就让公司再发一次。  
不负责任的跟单员（使用 UDP 协议）层只管将快递送到客户指定的地方，不管快递是否送到客户手上。

#### 网络层

> 网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。  
> 主要由 IP、ICMP 两个协议组成

网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。  
传输的地址使用的是 IP 地址。IP 地址和我们的住址有点相似，我们的住址可以从省到市再到街逐步缩小范围，直至我们住址。

<br>

IP 地址也有这样的能力，通过不断转发到更近的 IP 地址，最终可以到达目标地址。  
如何选择这条路，就看网络层了。

<br>

这好比是快递公司的路线规划者。快递公司有很多集散中心，根据集散中心的情况（是否拥堵），  
找出一条经过 n 个集散中心的路径将货物（数据）沿路运过去。

#### 数据链路层

> 该层负责物理层面上互连的节点之间的通信传输。  
> 例如与 1 个以太网相连的两个节点间的通讯。常见的协议有 HDLC、PPP、SLIP 等

###### 数据链路层会将 0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）

<br>

举个例子可能会更好理解，暂且把需要传输的数据看作为不同来源的水，如果直接倒入池子中时，是无法重新分辨出不同来源的水的。  
但如果将不同来源的灌入瓶子中并打上记号，那就能区分出不同来源的水。  
这也就是为什么要划分为具有意义的数据帧传送给对端。同时要注意的是，数据链路层只负责将数据运送给物理相连的两端，并不负责直接发送到最终地址。

_数据链路层可以看作是快递公司的司机，他们驾驶着汽车，将打包好的货物（数据帧）从一个城市（物理节点）运输到另一个城市。_

#### 物理层

> 物理层负责 0、1 比特流（0、1 序列）与电压高低、光的闪灭之间的互换。  
> 典型的协议有 RS 232C、RS 449/422/423、V.24 和 X.21、X.21bis 等

_看着高大上，其实是将数据的 0、1 转换成电信号或者光信号_

通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。  
而传输过程中的集线器、中继器、调制解调器等，也属于物理层的传输介质。物理层是 OSI 七层模型的物理基础，没有它就谈不上数据传输了。

<br>

物理层就是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征。

---

## dns 劫持是什么？

## 304 状态码的理解？

## https 讲一下过程

## TCP 和 UDP 的区别？TCP 怎样保证传输可靠

## http2.0 了解多少

<!-- _____________________________________________ -->

# 其他

## 做微信小程序有什么亮点，什么难点？

## 用户反馈进入页面白屏，如何排查错误

## 你在团队中的优势是什么？尤其是技术方面

---

## 关于前端性能优化？

#### 优化的目的

优化的目的在于让页面加载的更快，对用户操作响应更及时，为用户带来更好的用户体验  
对于开发者来说优化能够减少页面请求数，能够节省资源。

##### 网络优化

- 减少 http 请求数，css，js, image 等文件压缩合并，合理设置 http 请求缓存。
- 样式放头部，脚本放底部。
- 使用 CDN。
- 按需加载，显示进度条或者 loading

##### CSS 优化

- 避免使用 CSS 表达式
- 尽可能减少 CSS 选择器的层级
- 减少 TABLE 布局
- 移除空的样式
- 图片在加载前提前指定宽高或者脱离文档流，可避免加载后的重新计算导致的页面回流；

##### JS 优化

- 减少闭包的使用。过多使用闭包会产生很多不销毁的内存，内存过多会导致内存溢出。
- 避免使用 iframe, iframe 会嵌入其它页面，父页面渲染的时候，同时渲染子页面，渲染进度会变慢。
- 减少 dom 操作，减少页面重绘和重排。使用 css3 动画
- 尽可能使用事件委托。事件委托可以给动态元素绑定事件，而且基于事件委托实现，整体性能会比一个一个绑定事件高 50%。
- 注意防抖和节流

##### 图片优化

- 不用图片，尽量用 css3 代替。 比如说要实现修饰效果，如半透明、边框、圆角、阴影、渐变等，在当前主流浏览器中都可以用 CSS 达成。
- 使用矢量图 SVG 替代位图。对于绝大多数图案、图标等，矢量图更小，且可缩放而无需生成多套图。现在主流浏览器都支持 SVG 了，所以可放心使用！
- 使用恰当的图片格式。我们常见的图片格式有 JPEG、GIF、PNG。基本上，内容图片多为照片之类的，适用于 JPEG。而修饰图片通常更适合用无损压缩的 PNG。GIF 基本上除了 GIF 动画外不要使用。且动画的话，也更建议用 video 元素和视频格式，或用 SVG 动画取代。
- 按照 HTTP 协议设置合理的缓存。
- 使用字体图标 webfont、CSS Sprites 等。
- 用 CSS 或 JavaScript 实现预加载。WebP 图片格式能给前端带来的优化。
- WebP 支持无损、有损压缩，动态、静态图片，压缩比率优于 GIF、JPEG、JPEG2000、PG 等格式，非常适合用于网络等图片传输。

##### 图片懒加载与预加载

- 图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载

- 图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。

<br>

_为什么要将图片转为 base64 格式_

<br>

图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址;

- 提升性能: 网页上的每一个图片，都是需要消耗一个 http 请求下载而来的, 图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，base64 可以随着 HTML 的下载同时下载到本地.减少 https 请求。

- 加密: 让用户一眼看不出图片内容 , 只能看到编码。

- 方便引用: 在多个文件同时使用某些图片时, 可以把图片转为 base64 格式的文件, 把样式放在全局中, 比如 common.css, 以后在用的时候就可以直接加类名, 二不需要多层找文件路径, 会提升效率

## 登陆注册的前后端处理机制

## 移动端点击穿透

## 加密策略 encodeURI-Component 和 MD5

## 用户权限和登陆的校验处理

## 常见的排序方法？都熟悉哪些

## 做 PC 端多一些还是移动端多一些？遇到了什么难以解决的兼容性问题？

## nodejs 用过吗？

---

---

## token 的校验处理

## 移动端 300 毫秒延迟怎么解决？

## 同一个对象上绑定了多个事件，执行顺序是怎样的

## 有遇到过跨域问题吗？跨域的原理是什么

---

## 谈谈对 MVC、MVP、MVVM 的理解？

### web1.0 时代

没有前端概念，一个 web 应用采用.asp/java/php 编写  
项目可能由多个 jsp/php 文件构成  
每个文件中都包含了 HTML、CSS、JS、PHP 等代码

这种架构简单，缺点也非常明显，就是 jsp 代码非常难以维护

> 为了让开发更加便捷，代码更易维护，前端职责更加清晰  
> MVC 开发模式出现

前端展示以模板的形式出现，典型的就是 Spring、Stucts、Hibernate

这种框架职责清晰，代码易维护  
但此时的 MVC 仅限于后端，前端只负责 view 层  
一切都是由后端在渲染，给前端你的只是模板文件  
前端写的都是静态页面，并不需要涉及数据  
前端也逐渐沦为了切图仔

> 这种开发模式的缺点也很明显，一是页面开发效率不高，二是前后端职责不清

### web2.0 时代

自从谷歌 gmail 的出现，ajax 风靡全球  
这时前后端的职责就更加清晰了  
前端可以通过 ajax 和后端进行数据交互了！

ajax 使页面进行局部刷新，减少了服务端负载和流量消耗，用户体验也极大提升  
这时，专职的前端工程师出现  
同时前端类库也开始大力发展，jQuery 就是最出名！

当然，这种架构还是存在问题

> 缺乏可行的开发模式承载了更复杂的业务需求  
> 页面内容杂糅在一起  
> 一旦应用规模增大，就变的难以维护，因此前端 MVC 出现！

### 前后端分离后的架构演变——MVC、MVP 和 MVVM

#### MVC

前端的 MVC 与后端类似

- Model 负责保存应用数据，与后端数据进行同步
- Controller 负责业务逻辑，根据用户行为对 Model 数据进行修改
- View 负责视图层，将 Model 中的数据可视化

这种模型，理论上可行，实际开发中，  
一个小小的事件操作，都必须经过这样一个流程，  
开发变的不再便捷了

还有个大问题，就是

View 比较庞大，而控制层比较单薄，很多开发者会在视图层写一些逻辑代码  
这就导致了视图层 view 中的内容越来越大，而 controller 变的越来越单薄

有缺陷就有变革  
前端变化中，似乎少了 MVP 模式  
是因为 Angular 早早的将 MVVM 框架带入了前端  
MVP 模式在前端开发虽不常见，但是在安卓等原生开发中，还是会被考虑

_那什么是 MVP 呢？_

#### MVP

与 MVC 接近，P 指的是 Presenter，P 可以理解为一个中间人  
负责和 model 和 view 的双向交互  
P 负责的太多了，体积会越来越大

同样体积增加后难以维护

要解决这些问题，还得从 MVVM 思想中找啊

#### MVVM

_那什么是 MVVM 呢？_

- Model
- View
- ViewModel

![avatar](/images/mvvm.png)

_ViewModel 通过实现了一套数据响应机制自动响应 Model 中数据的变化  
同时 ViewModel 会实现一套自动更新策略自动将数据变化转为视图更新_

通过事件监听响应 view 中用户修改 Model 中的数据

> 这样 ViewModel 中就减少了大量的 DOM 操作  
> MVVM 保持了 view 和 model 松耦合的同时，还减少了维护  
> 这简直就是一个革命性的变革

##### 最后总结一下面试时的回答思路：

- 这三个都是框架模式，设计目标都是为了解决 Model 和 View 的耦合问题
- MVC 模式出现较早而且主要应用于后端，它分层清晰，缺点是数据流混乱，维护存在问题
- MVP 模式是 MVC 的进化形式，Presenter 作为中间层通信，解决了两者的耦合问题，但 P 层会过于臃肿导致维护问题
- MVVM 模式在前端领域广泛应用，不仅解决了 MV 耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和 DOM 操作，提高了开发效率的同时，还保持了优越性能的表现

---

## 前端缓存了解多少？分为哪几类

---

## 对 SEO 有什么了解

##### _每一个程序员都应该了解 SEO_

<br>

SEO，Search Engine Optimization
搜索引擎优化

<br>

利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名  
目的是让其在行业内占据领先地位，获得品牌收益  
很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移

##### 我们先了解一下用浏览器搜索时，发生了什么

- 用户输入查询内容
- 查询处理以及分词技术
- 确定搜索意图及返回相关、新鲜的内容

#### _为什么谷歌上可以搜索整个互联网的内容？_

因为，他解析并存储了  
而更有意思的是，他会为同样的内容建立一个索引或者说分类，按照一定的相关性，针对于某个关键词的内容

<br>

PageRank 对于一个网站来说是相当重要的，只是这个相比也比较复杂  
包括其他网站链接向你的网站，以及流量，当然还有域名等等

正常情况下除了像腾讯这类的 QQ 空间自我封闭的网站外都需要 SEO  
或者不希望泄露一些用户隐私如 Facebook、人人等等

> SEO 与编程的最大不同之处在于  
> 编程的核心是技术，SEO 的核心是内容

我们先来了解一下

#### 搜索引擎的工作原理

在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。

<br>

随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词  
如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。

<br>

反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。

<br>

当用户搜索时，就能检索出与关键字相关的网址显示给访客。

<br>

一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是 flash 和 js 等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用

<br>

相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为 SEO

#### 白帽和黑帽

搜索引擎优化的技术手段主要有黑帽（black hat）、白帽（white hat）两大类

<br>

通过作弊手法欺骗搜索引擎和访问者，最终将遭到搜索引擎惩罚的手段被称为黑帽，比如隐藏关键字、制造大量的 meta 字、alt 标签等

<br>

而通过正规技术和方式，且被搜索引擎所接受的 SEO 技术，称为白帽

当然我们是不支持黑帽这种方式的  
所以这次我们好好聊聊白帽

> 前端是构建网站中很重要的一个环节，前端的工作主要是负责页面的 HTML+CSS+JS，优化好这几个方面会为 SEO 工作打好一个坚实的基础

> 通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂（提升用户体验），也能让“蜘蛛”看懂（提高搜索引擎友好度）

### 我们该怎么做？

- ##### 控制首页链接数量

网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量

<br>

但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好

- ##### 扁平化的目录层次

尽量让“蜘蛛”只要跳转 3 次，就能到达网站内的任何一个内页

- ##### 对导航的优化

导航应该尽量采用文字方式，也可以搭配图片导航

<br>

但是图片代码一定要进行优化，<img> 标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字

<br>

其次，在每一个网页上应该加上面包屑导航

_这样做的好处有？_

- 从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置  
  帮助用户很快了解网站组织形式
  从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作

- 对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率

##### 网站的结构布局——不可忽略的细节

- 页面头部：logo 及主导航，以及用户的信息

* 页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章

  这样做的好处是：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重

<br>

- 页面底部：版权信息和友情链接

> 特别注意：分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转

而“ 首页 下一页 尾页 ”这种写法是不推荐的  
特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃

##### 把重要内容 HTML 代码放在最前

搜索引擎抓取 HTML 内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边

<br>

例如，在左栏和右栏的代码不变的情况下，只需改一下样式，利用 float:left 和 float:right 就可以随意让两栏在展现上位置互换，这样就可以保证重要代码在最前

让爬虫最先抓取。同样也适用于多栏的情况

##### 控制页面的大小，减少 http 请求，提高网站的加载速度

一个页面最好不要超过 100k，太大，页面加载速度慢

当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开

#### 从代码层面说一说优化

- 突出重要内容---合理的设计 title、description 和 keywords

> 这几个标签都是突出重点，切勿过分堆叠

- 书写语义化标签，符合 W3C 标准

- 注意 a 标签

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而外部链接，链接到其他网站的，则要加上 el="nofollow" 属性, 告诉 “蜘蛛” 不要爬  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了

- 标题要用 h1 标签

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1 标签自带权重“蜘蛛” 认为它最重要  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个页面有且最多只能有一个 H1 标签，放在该页面最重要的标题上面

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如首页的 logo 上可以加 H1 标签。副标题用 h2 标签, 而其它地方不应该随便乱用 h 标题标签

- strong、em 标签

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strong 标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em 标签强调效果仅次于 strong 标签  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b、i 标签：只是用于显示效果时使用，在 SEO 中不会起任何效果

- 谨慎使用 display：none

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不想显示的文字内容，应当设置 z-index 或缩进设置成足够大的负数偏离出浏览器之外

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为搜索引擎会过滤掉 display:none 其中的内容

- 尽量少用 JS 输出内容，少用 iframe

---

## 前端路由和后端路由的区别？单页面应用和多页面应用？

#### 前端路由

##### 定义

在单页面应用，大部分页面结构不变，只改变部分内容的使用

##### 优点

用户体验好，不需要每次都从服务器全部获取，快速展现给用户

##### 缺点

使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。  
单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

#### 后端路由

通过用户请求的 url 导航到具体的 html 页面；  
每跳转到不同的 URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回 HTML，  
也可以是直接返回模板 HTML，然后由前端 js 再去请求数据，  
使用前端模板和数据进行组合，生成想要的 HTML

---

#### 前后端路由对比

##### 性能和用户体验上来说

后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。

##### URL 方面来说

在某些场合中，用 ajax 请求，可以让页面无刷新，页面变了但 Url 没有变化，用户就不能复制到想要的地址
<br>  
_用前端路由做单页面网页就很好的解决了这个问题_  
但是前端路由使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

说到这我们就不得不说一下单页面和多页面

##### 单页面有什么优势？

- 不存在页面切换问题，因为只在同一个页面间切换，会更流畅  
  而且可以附加各种动画和过度效果，用户体验更好
- 可以用到 vue 的路由和状态保持，不用担心切换造成的数据不同步
- 打包方便，有现成的脚手架可以用，也比较不容易出问题

##### 单页面的劣势

- 所有逻辑和业务都在一个页面上，逻辑上不是很清楚，当业务变得复杂的时候改动起来就比较麻烦
- 鸡蛋都在一个篮子里，只要一个地方出现错误，可能导致整个页面出错
- 所有代码都在一个页面，首次加载耗时较长，页面体积较大

> 只有一张 Web 页面的应用，是一种从 Web 服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css 等)仅需加载一次页面跳转：  
> 使用 js 中的 append/remove 或者 show/hide 的方式来进行页面内容的更换； 数据传递：可通过全局变量或者参数传递，进行相关数据交互

_使用场景： 适用于高度追求高度支持搜索引擎的应用_

##### 那么多页面有什么优势呢？

- 逻辑清楚，各个页面按照功能和逻辑划分，不用担心业务复杂度
- 单个页面体积较小，加载速度比较有保证
- 多页面跳转需要刷新所有资源，每个公共资源(js、css 等)需选择性重新加载
- 页面跳转：使用 window.location.href = "./index.html"进行页面间的跳转；
- 数据传递：可以使用 path?account="123"&password=""路径携带数据传递的方式，或者 localstorage、cookie 等存储方式

_使用场景： 高要求的体验度，追求界面流畅的应用_

##### 多页面当然也有劣势

- 重复代码较多
- 页面经常需要切换，切换效果取决于浏览器和网络情况，对用户体验会有一定负面影响
- 无法充分利用 vue 的路由和状态保持，在多个页面之间共享和同步数据状态会成为一个难题

---

## 前端鉴权了解过吗？

## 设计模式了解多少？

## 对 webpack 的理解

## 快速排序的思路是怎样的

---

## 对 JS 单线程的理解

##### 单线程是 JavaScript 最大的特点

_为什么不是多线程呢？提高效率不好吗？_

如果两个命令同时操作一个 DOM
一个添加内容，一个删除节点  
请问这个时候该怎么办？以哪个线程为准呢？

##### 异步的出现

js 是单线程的，只能自上而下的运行  
如果上一行运行了很长很长时间，那下面的代码就没法执行力啦，阻塞了，对用户而言，页面直接卡死啦！！这还能用吗？！

_那异步到底是如何实现的呢？_

##### event loop 事件循环

首先 js 主线程会不断循环

如果遇到同步任务，创建执行上下文，按顺序进入执行栈

如果是异步，js 当然不会一直等待它的结果，不然后面阻塞了，怎么办呢

<img src="/images/evenloop.png" width="60%">

调用栈，也叫做执行栈，它就像一个水桶一样  
js 代码按照从上至下运行，一旦需要执行的代码，会立刻放入调用栈中  
按照后进先出的原则

> 记住单线程 js 的执行逻辑  
> 调用栈 > 微任务 > 消息队列

事件列表会依次把每个事件压入到调用栈中准备执行  
如果遇到的是 setTimeout 这种异步函数，同样会压入调用栈中

只不过接下来会把异步函数中的回调函数放入消息队列  
当调用栈都执行完毕后，再回头来调取消息队列依次执行

<!--
      function func1(){    // 5、接第四步，执行func1
          console.log(1);    // 6、压入 console进调用栈，打印得到 1，出栈，
          // 7、func1 执行结束，func1 出栈
      }
      function fun2(){     // 2、执行func2
          console.log(2);   // 3、压入console进调用栈，打印得到 2，出栈
          func1();     // 4、发现函数 func1，压入调用栈中，此时 func1 在 func2的上面
          console.log(3);  // 8、func1 结束，代码继续，console.log 打印 3 出栈
          // 9、func2 执行结束，func2 出栈
      }
      func2();  // 1、发现函数 func2，压入调用栈中 -->

![avatar](/images/even1.png)

<!-- <img src="/images/even1.png" > -->

_我们再看一下带有异步的例子_

![avatar](/images/even2.png)

_更复杂一点，我们加入 promise_

![avatar](/images/even3.png)

> 事件循环 event loop 就是让 js 既是单线程，又不会阻塞下面运行的核心机制  
> 也是 js 并发模型的基础

https://juejin.im/post/5e37de90f265da3e413f6150

---

## 事件模型能介绍一下吗

## 如何管理项目

## 对算法了解怎么样？常用的排序算法？

## 讲一下性能优化？具体哪些优化的收益更大一些

# 算法

## 冒泡排序

## 快速排序
