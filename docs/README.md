# HTML

## 谈一谈元素属性 href 和 src 的区别？

##### 字面区别

##### href

Hypertext Reference  
 超文本 &nbsp;&nbsp;引用或参照

##### src

Source 资源

_英文字面上看来，好像是差不多意思_

    <img src="smile.png">
    <a href="smile.png">笑一下</a>

这段代码带来的区别是什么呢？

- img 会直接把图片渲染在页面上，src 引用的资源直接成为了当前文档的一部分，因为它把资源下载了下来并绑定在文档上，浏览器遇到这个属性会先下载这个资源并编译，执行完了之后才会进行下一步  
  就像汽车加油，加完了才能走
  <br>

- 而 a 标签不会渲染图片，需要点击 a 标签，才能在另一个地址看到图片  
  href 建立了一个通道，这个通道联系着其他资源

##### 主要使用场景

#### href

- link
- a

#### src

- img
- style
- script
- input
- iframe

<br>

> href 建立超链接，通过通道联系引用资源  
> src 会把资源下载下来，代替当前元素，嵌入到文档中

---

## 什么是标签语义化

## doctype 的作用

## 块级标签都有哪些？

ssh root@192.168.31.90

编辑 vim ~/.ssh/config 文件添加以下内容

> Host houdunren
> Hostname 192.168.31.90
> Port 22
> User root

现在直接使用 ssh houdunren 就可以登录服务器了

# CSS

## 伪类和伪元素有什么区别？

## 为什么要清除浮动？如何清除？

## 不同选择器的权重怎么算的

## 前端几大经典布局的实现方案？

## toB 和 toC 的区别

## VUE 的性能优化

## 对 Vue3.0 的新特性有没有了解？

## 移动端布局的几大方案？

#### 1、media（主流)

适合 Pc 端移动端用一套项目  
像京东这种，pc 端移动端是不一样的，那就不适合用这种

#### 2、rem（主流)

针对移动端有单独设计

#### 3、flex

部分布局可以用 flex

#### 4、vh/vw

通过调整视口百分比，跟百分比类似，也称为百分比布局

---

## css 的 display 可以取什么值？

## 用 ts 实现一个数组的去重

## mvvm 框架原理

## 手写 promise 的实现

## flex 布局和传统布局的区别

## http 各种状态码的含义

## 什么时候用 flex ？除了这种方式居中还能用什么？响应式布局还能怎么做？盒子模型？

## opacity 兼容处理？

> 上面的操作也已经实现的 VSCODE 远程开发的基础步骤

## 介绍一下 postion 属性

## CSS 中 link 和 import 的区别

- link 属于 HTML 标签，@import 是 CSS 提供的
- 页面被加载的时候 link 就会被加载，而 @import 需要等到页面加载完才会加载
- import 只能在 IE5 以上使用，link 是 HTML 标签，无兼容问题
- link 的权重高于 @import

#配置源

## filter 还能做哪些事？

通过添加源可以加快软件下载，同时更多的源也提供更丰富的软件

如果下载速度可以就不用配置了

---

## 盒子水平垂直居中的方案？

这个问题在项目中很常见，开始我用的什么。。<br>
后来 css3 出现，我尝试用什么。。。<br>
后来我在博客上看到了还有什么什么技术。。于是尝试使用。。<br>

---

<strong>记住一共有五中方案</strong>

- 定位三种
- display：flex
- javascript
- display：table-cell

###### 哈哈

<strong> 定位

## 不同选择器的权重怎么算的

## 说一说盒模型吧

## position 和 float 的区别？

## CSS 怎么画出一个三角形

## 旋转动画怎么做？

---

## rem 和 em 的区别

##### 区别

- rem:基于 html 元素字体大小
- em：根据使用它的元素大小决定（其实不是根据父元素，是因为继承了父元素，所以造成误解）

##### 深刻理解

> 他们都是灵活可以扩展的单位  
> 你使用 1rem 或者 1em ，其实都可以被浏览器翻译成 16px-160px 以及其他任何值

浏览器使用 px，那 1px 就显示为 1px

- rem：如果默认根元素字体为 16px，那你的 10rem 就会渲染成 160px
- em：如果一个 div 有 18px 字体大小，那此时你的元素 10em 就是 180px

浏览器默认虽然是 16px，但是浏览器的这个默认参数，用户是可以自己改变的
它支持 9-72px 之间的任何值！！

> html 根元素 继承的就是 浏览器设置的字体大小！除非重写一个具体单位来覆盖
> 所以表面上 rem 根据的是 html 根元素的字体大小，但实际可能是来自浏览器的设置大小

如果我们使用 rem，请确保无论用户如何设置自己的浏览器，我们都要显示正常

---

# JavaScript

## 复制一个数组有哪些方法？哪个方法最好

## cdn 的作用和原理？

## 响应式的浏览器原理？

## async await 原理？

## 了解 ES6 中的 Set 和 Map 吗？

https://juejin.im/post/5ee71e92f265da76f65329fe

---

## 说一下原型链吧（proto，prototype）

先来说一下构造函数

##### 构造函数

> 每个构造函数(constructor)都有一个原型对象(prototype)  
> 原型对象都包含一个指向构造函数的指针, 而实例(instance)都包含一个指向原型对象的内部指针.

_看一个例子_

<br>

<img src="/images//constor1.png">

person1 和 person2 都是 Person 的实例  
这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person 即：

    console.log(person1.constructor == Person) //true
    console.log(person2.constructor == Person) //true

### prototype

每个构造函数都有一个 prototype 属性，指向调用该构造函数而创建的实例的原型  
也就是这个例子中的 person1 和 person2 的原型

<img src="/images//constor2.png">

### proto

这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫 proto  
这个属性会指向该对象的原型

    function Person() {}
    var person1 = new Person()
    console.log(person1.__proto__ === Person.prototype) // true

### constructor

每个原型都有一个 constructor 属性指向关联的构造函数

    function Person() {}
    var person1 = new Person()
    console.log(Person === Person.prototype.constructor) // true
    console.log(person1.__proto__ === Person.prototype) // true

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性  
如果还查不到，就去找原型的原型，一直找到最顶层为止

> 这个查找的过程，就叫做原型链

---

## 了解 vue-lazyloader 吗

## 如何判断一个类型是数组？instanceOf 实现？

https://juejin.im/post/5b0b9b9051882515773ae714

## 提交表单有哪些常用方法？应用层通信层发生了哪些过程？

## let、const 及 var 的区别？

> 这个问题，涉及到变量提升

    console.log(a);  // undefined
    var a = 1;

上述代码就是一个变量提升  
 在声明变量之前，我们就可以使用它

这段代码可以翻译为：

    var a
    console.log(a)
    a = 10

好了，不仅变量可以提升  
 函数也会提升

    console.log(a)  // f a(){}
    function a(){}
    var a = 1

看了上面两个例子，我们差不多知道 var 存在的问题了  
接下来我们来看 let 和 const

    var a = 1
    let b = 1
    const c = 1
    console.log(window.b)  //undefined
    console.log(window.c)  //undefined

    function test(){
      console.log(a)
      let a
    }
    test()

我们发现，使用了 let 和 const 后  
变量不会被挂载到 window 上
这就和 var 有了明显的区别

---

## 解构赋值和拓展运算符

## Set/Map 数据结构

---

## null 和 undefined 有什么区别

- undefined 声明了变量，但没有赋值，它存在，但没有值
- null 没有值，根本就不存在，没有任何可读的东西  
  <br>


    var a ;

声明了，但没有赋值，此时 a 就是 undefined

   <br>

##### 用 typeof 判断类型，会看到两者的区别

    typeof(null)  //object
    typeof(undefined)  //undefined

##### 和数字相加的区别

- undefined + 数字 = NaN
- null + 数字 = 数字

---

## 事件委托是什么？主要解决什么问题？

http://www.zhangyunling.com/564.html

---

## 了解基本的数据类型吗

https://juejin.im/post/5e23eae9f265da3e2a79230c

##### 先了解一下为什么需要数据类型？

计算机中，不同数据占据的存储空间是不同的  
为了充分利用空间，需要定义不同数据类型

> 简单类型又叫基本数据类型，或者值类型  
> 复杂类型又叫做引用类型

当我们声明一个变量时

    var x = "变量"

实际是在内存空间中开辟了一块地方来存储这个数据  
但是我们调用这个变量的时候不能靠输入十六位进制来取值吧，太麻烦了  
所以起了一个变量名，实际就是在引用内存地址

#### String

单引号或双引号
<br><br>

#### Number

常规包含：

- 浮点类、整数
- 二进制
- 十六进制

三个特殊值：

- Infinity，无穷大，大于任何值
- -Infinity，无穷小，小于任何值
- NaN，非数值
  <br><br>

#### Boolean

有两个值

- true == 1
- false == 0

javascript 中任何值都可以转换为布尔值。

<br><br>

#### Undefined

变量没有赋值时的默认值

<br>

#### Null

---

## Promise 设计模式？

## 移动端的触摸事件了解吗

## Interator 迭代器

## 一般怎么判断基本的数据类型

https://juejin.im/post/5b0554c86fb9a07acb3d3ddc

## 普通函数和构造函数的区别

## 深拷贝一个数组怎么做

## async / await 及实现原理

https://juejin.im/post/5a9516885188257a6b061d72

## 了解 return 吗？

## AJAX 核心四步操作？交互过程？

## 底层运行机制：微任务宏任务和事件循环机制

## Generator 生成器函数

## 手写懒加载函数

## 怎么理解防抖和节流的

https://juejin.im/post/5dc3716cf265da4d417652ff

## JS 底层运行机制：单线程和同步异步编程

## 了解作用域吗？怎么预防作用域污染

https://juejin.im/post/5e264f7d51882520c02c8f3e

## 闭包怎么理解？项目中用到过吗

https://juejin.im/post/5e264f7d51882520c02c8f3e

---

## 为什么 0.1 + 0.2 != 0.3

我们都知道计算机是通过二进制来存储东西的，那么 0.1 在二进制中会表示为

    // (0011) 表示循环
    0.1 = 2^-4 \* 1.10011(0011)

我们可以发现，0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002

    0.100000000000000002 === 0.1 // true

那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002

    0.200000000000000002 === 0.2 // true

所以这两者相加不等于 0.3 而是 0.300000000000000004

    0.1 + 0.2 === 0.30000000000000004 // true

_那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？_

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

    console.log(0.100000000000000002) // 0.1

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

    parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true

---

## 堆栈内存的理解

---

## 箭头函数和普通函数的区别

https://juejin.im/post/5c76972af265da2dc4538b64

- 箭头函数更加简洁
- 箭头函数是不存在 this，它的 this 继承的是函数上下文中的 this

---

## 说一下拷贝对象吧，深拷贝浅拷贝

https://juejin.im/post/5ad5b908f265da23870f540d

## fetch 基础和实战

## 谈一谈变量提升？

## json 的数据格式都介绍一下

## JS 是否了解过函数式编程

## 跨域怎么处理？都知道什么方法？ jsonp 和 cors 哪个更安全

https://segmentfault.com/a/1190000011145364

## 异步的处理方式？都是怎么处理的

sudo sed -i 's/mirrorlist=/#mirrorlist=/g' CentOS-Base.repo CentOS-AppStream.repo CentOS-Extras.repo
sudo sed -i 's/#baseurl=/baseurl=/g' CentOS-Base.repo CentOS-AppStream.repo CentOS-Extras.repo
sudo sed -i 's/http:\/\/mirror.centos.org/https:\/\/mirrors.aliyun.com/g' CentOS-Base.repo CentOS-AppStream.repo CentOS-Extras.repo

yum makecache

CENTOS 7

<!-- ---------------------------------------------------------------- -->

# Vue

---

## 为什么使用 vue 框架而不是使用其他框架？

- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；
  <br>

- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；
  <br>

- 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
  <br>

- 虚拟 DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言，vue 存在很大的优势。

---

## vuex 是什么？怎么使用？哪种功能场景使用？

vue 框架中状态管理。在 main.js 引入 store，注入

新建了一个目录 store.js，….. export

场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

#### vuex 的属性

- state：基本数据（数据源存放地）
- getters：从基本数据派生出来的数据
- mutations：提交更改数据的方法，同步！
- actions：像一个装饰器，包裹 mutations，使之可以异步。
- modules：模块化 Vuex

---

## Vue 和 Vuex 的差异？

## Vue 设计原则的理解？

## vue 从 data 改变到页面渲染的过程

## 如果没有 vue-router，你们还会做单页面应用吗

## Vuex 的触发过程 （actions，state，view）？

## 关于 VUE 的性能优化

## 双向绑定原理？

## 组件的设计原则

## 对 flutter 的了解

## 讲一下 vue 有哪些特性

## 谈谈对 Vue 组件化的理解

---

## vue 中 key 的作用？说说对它的理解

这是用来标记 DOM 元素的，区分不同的相同 DOM  
从而提升性能

> 从原则上来讲，最好都加上 Key

通常情况下，我们都会将 key 绑定为 id
如果数组中没有 id 属性，怎么办呢？
使用索引 —— index

    <li v-for="item in fruits" :key="index"></li>

---

## 对 Vue 源码了解吗

## vue 里的虚拟 dom 是怎么回事

https://juejin.im/post/5d36cc575188257aea108a74

---

## vue 的生命周期讲一下

### 1、beforeCreate

这一步，是开始创建实例化，你拿不到任何实例里面的东西  
包括 data 、methods、监听等

> 实例里的任何东西，任何，你都，拿不到！

### 2、created

实例创建完成了！  
这个阶段可以调用 methods 中的方法，或者操作 data 中的数据了

> 这一步就是最早拿到数据和方法的地方了

### 3、beforeMount

执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的

> 前两部操作里，你无论如何都是拿不到真实 dom 的  
> 想拿到 dom 元素就去 mounted 里

### 4、mounted

此阶段，Vue 实例已经初始化完成  
组件脱离了创建阶段，进入运行阶段  
可以操作 DOM 元素了，但也只能拿初始化时候的 dom 元素

> 如果存在异步操作把 dom 更改了，那你还是拿不到
> 只能去 updated 里找啦

### 5、beforeUpdate

当执行这个钩子时，页面中的显示的数据还是旧的，data 中的数据是更新后的， 页面还没有和最新的数据保持同步

### 6、updated

这次能拿到更新后的数据了

> 但是注意：
> update 只要相关数据更改一次就会执行一次
> （mounted 后改过一次数据都会执行这个）

所以不要在当前的钩子里修改组件中的 data 数据  
否则会触发 beforeUpdate、updated 两个钩子

_那样就进入了死循环！！！！无解了！！_

<br>
这里引申一下：

- updated 对所有数据变化进行统一处理
- watch 对具体某个数据变化做处理
- nextTick 对某个数据的某次变化做处理

### 7、beforeDestroy

实例进入销毁阶段，此时，实例仍可使用  
所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁

### 8、destroyed

_*Boom！*_  
实例销毁了，么得了  
里面所有的东西，都！没！了！！

##### created 和 mounted 的区别

- created 在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图
- mounted 在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。

#### 总结一下：

生命周期看起来是 8 个环节  
其实按照功能性来分，就是 4 个步骤：

- 实例创建前后 create
- 挂载 dom 前后 mount
- 更新数据前后 update
- 销毁实例前后 destroy

---

## Vue 的设计思路有了解吗

<!-- --------------------------------------------------- -->

# 计算机和浏览器原理

## 如何保证浏览器不受脚本的恶意攻击

---

## 浏览器渲染页面的过程

https://juejin.im/post/59f1cd855188252c224d3b4e

## 浏览器输入 URL 到整个页面渲染出来经历的过程详细讲解一下

<!-- -------------------------------------------------------- -->

# 网络协议

## http 和 https 有什么区别？比如性能方面

## http 的请求头都包括哪些？

## OSI 七层协议？

## dns 劫持是什么？

## 304 状态码的理解？

## https 讲一下过程

## TCP 和 UDP 的区别？TCP 怎样保证传输可靠

## http2.0 了解多少

## http 各种状态码的含义

<!-- _____________________________________________ -->

# 其他

## 做微信小程序有什么亮点，什么难点？

## 用户反馈进入页面白屏，如何排查错误

## 你在团队中的优势是什么？尤其是技术方面

---

## 关于前端性能优化？

#### 优化的目的

优化的目的在于让页面加载的更快，对用户操作响应更及时，为用户带来更好的用户体验  
对于开发者来说优化能够减少页面请求数，能够节省资源。

##### 网络优化

- 减少 http 请求数，css，js, image 等文件压缩合并，合理设置 http 请求缓存。
- 样式放头部，脚本放底部。
- 使用 CDN。
- 按需加载，显示进度条或者 loading

##### CSS 优化

- 避免使用 CSS 表达式
- 尽可能减少 CSS 选择器的层级
- 减少 TABLE 布局
- 移除空的样式
- 图片在加载前提前指定宽高或者脱离文档流，可避免加载后的重新计算导致的页面回流；

##### JS 优化

- 减少闭包的使用。过多使用闭包会产生很多不销毁的内存，内存过多会导致内存溢出。
- 避免使用 iframe, iframe 会嵌入其它页面，父页面渲染的时候，同时渲染子页面，渲染进度会变慢。
- 减少 dom 操作，减少页面重绘和重排。使用 css3 动画
- 尽可能使用事件委托。事件委托可以给动态元素绑定事件，而且基于事件委托实现，整体性能会比一个一个绑定事件高 50%。
- 注意防抖和节流

##### 图片优化

- 不用图片，尽量用 css3 代替。 比如说要实现修饰效果，如半透明、边框、圆角、阴影、渐变等，在当前主流浏览器中都可以用 CSS 达成。
- 使用矢量图 SVG 替代位图。对于绝大多数图案、图标等，矢量图更小，且可缩放而无需生成多套图。现在主流浏览器都支持 SVG 了，所以可放心使用！
- 使用恰当的图片格式。我们常见的图片格式有 JPEG、GIF、PNG。基本上，内容图片多为照片之类的，适用于 JPEG。而修饰图片通常更适合用无损压缩的 PNG。GIF 基本上除了 GIF 动画外不要使用。且动画的话，也更建议用 video 元素和视频格式，或用 SVG 动画取代。
- 按照 HTTP 协议设置合理的缓存。
- 使用字体图标 webfont、CSS Sprites 等。
- 用 CSS 或 JavaScript 实现预加载。WebP 图片格式能给前端带来的优化。
- WebP 支持无损、有损压缩，动态、静态图片，压缩比率优于 GIF、JPEG、JPEG2000、PG 等格式，非常适合用于网络等图片传输。

##### 图片懒加载与预加载

- 图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载

- 图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。

<br>

_为什么要将图片转为 base64 格式_

<br>

图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址;

- 提升性能: 网页上的每一个图片，都是需要消耗一个 http 请求下载而来的, 图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，base64 可以随着 HTML 的下载同时下载到本地.减少 https 请求。

- 加密: 让用户一眼看不出图片内容 , 只能看到编码。

- 方便引用: 在多个文件同时使用某些图片时, 可以把图片转为 base64 格式的文件, 把样式放在全局中, 比如 common.css, 以后在用的时候就可以直接加类名, 二不需要多层找文件路径, 会提升效率

## 登陆注册的前后端处理机制

## 移动端点击穿透

## 加密策略 encodeURI-Component 和 MD5

## 存储方案 cookie、webStorage、session 等

## 用户权限和登陆的校验处理

## 常见的排序方法？都熟悉哪些

## 做 PC 端多一些还是移动端多一些？遇到了什么难以解决的兼容性问题？

## nodejs 用过吗？

## 正则表达式的使用程度

---

---

## token 的校验处理

## 移动端 300 毫秒延迟怎么解决？

## 同一个对象上绑定了多个事件，执行顺序是怎样的

## 有遇到过跨域问题吗？跨域的原理是什么

---

## 谈谈对 MVC、MVP、MVVM 的理解？

### web1.0 时代

没有前端概念，一个 web 应用采用.asp/java/php 编写  
项目可能由多个 jsp/php 文件构成  
每个文件中都包含了 HTML、CSS、JS、PHP 等代码

这种架构简单，缺点也非常明显，就是 jsp 代码非常难以维护

> 为了让开发更加便捷，代码更易维护，前端职责更加清晰  
> MVC 开发模式出现

前端展示以模板的形式出现，典型的就是 Spring、Stucts、Hibernate

这种框架职责清晰，代码易维护  
但此时的 MVC 仅限于后端，前端只负责 view 层  
一切都是由后端在渲染，给前端你的只是模板文件  
前端写的都是静态页面，并不需要涉及数据  
前端也逐渐沦为了切图仔

> 这种开发模式的缺点也很明显，一是页面开发效率不高，二是前后端职责不清

### web2.0 时代

自从谷歌 gmail 的出现，ajax 风靡全球  
这时前后端的职责就更加清晰了  
前端可以通过 ajax 和后端进行数据交互了！

ajax 使页面进行局部刷新，减少了服务端负载和流量消耗，用户体验也极大提升  
这时，专职的前端工程师出现  
同时前端类库也开始大力发展，jQuery 就是最出名！

当然，这种架构还是存在问题

> 缺乏可行的开发模式承载了更复杂的业务需求  
> 页面内容杂糅在一起  
> 一旦应用规模增大，就变的难以维护，因此前端 MVC 出现！

### 前后端分离后的架构演变——MVC、MVP 和 MVVM

#### MVC

前端的 MVC 与后端类似

- Model 负责保存应用数据，与后端数据进行同步
- Controller 负责业务逻辑，根据用户行为对 Model 数据进行修改
- View 负责视图层，将 Model 中的数据可视化

这种模型，理论上可行，实际开发中，  
一个小小的事件操作，都必须经过这样一个流程，  
开发变的不再便捷了

还有个大问题，就是

View 比较庞大，而控制层比较单薄，很多开发者会在视图层写一些逻辑代码  
这就导致了视图层 view 中的内容越来越大，而 controller 变的越来越单薄

有缺陷就有变革  
前端变化中，似乎少了 MVP 模式  
是因为 Angular 早早的将 MVVM 框架带入了前端  
MVP 模式在前端开发虽不常见，但是在安卓等原生开发中，还是会被考虑

_那什么是 MVP 呢？_

#### MVP

与 MVC 接近，P 指的是 Presenter，P 可以理解为一个中间人  
负责和 model 和 view 的双向交互  
P 负责的太多了，体积会越来越大

同样体积增加后难以维护

要解决这些问题，还得从 MVVM 思想中找啊

#### MVVM

_那什么是 MVVM 呢？_

- Model
- View
- ViewModel

![avatar](/images/mvvm.png)

_ViewModel 通过实现了一套数据响应机制自动响应 Model 中数据的变化  
同时 ViewModel 会实现一套自动更新策略自动将数据变化转为视图更新_

通过事件监听响应 view 中用户修改 Model 中的数据

> 这样 ViewModel 中就减少了大量的 DOM 操作  
> MVVM 保持了 view 和 model 松耦合的同时，还减少了维护  
> 这简直就是一个革命性的变革

##### 最后总结一下面试时的回答思路：

- 这三个都是框架模式，设计目标都是为了解决 Model 和 View 的耦合问题
- MVC 模式出现较早而且主要应用于后端，它分层清晰，缺点是数据流混乱，维护存在问题
- MVP 模式是 MVC 的进化形式，Presenter 作为中间层通信，解决了两者的耦合问题，但 P 层会过于臃肿导致维护问题
- MVVM 模式在前端领域广泛应用，不仅解决了 MV 耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和 DOM 操作，提高了开发效率的同时，还保持了优越性能的表现

---

## 前端缓存了解多少？分为哪几类

## 对 SEO 有什么了解

## 前端路由和后端路由的区别？单页面应用和多页面应用？

#### 前端路由

##### 定义

在单页面应用，大部分页面结构不变，只改变部分内容的使用

##### 优点

用户体验好，不需要每次都从服务器全部获取，快速展现给用户

##### 缺点

使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。  
单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置

#### 后端路由

通过用户请求的 url 导航到具体的 html 页面；  
每跳转到不同的 URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回 HTML，  
也可以是直接返回模板 HTML，然后由前端 js 再去请求数据，  
使用前端模板和数据进行组合，生成想要的 HTML

---

#### 前后端路由对比

##### 性能和用户体验上来说

后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。

##### URL 方面来说

在某些场合中，用 ajax 请求，可以让页面无刷新，页面变了但 Url 没有变化，用户就不能复制到想要的地址
<br>  
_用前端路由做单页面网页就很好的解决了这个问题_  
但是前端路由使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

说到这我们就不得不说一下单页面和多页面

##### 单页面有什么优势？

- 不存在页面切换问题，因为只在同一个页面间切换，会更流畅  
  而且可以附加各种动画和过度效果，用户体验更好
- 可以用到 vue 的路由和状态保持，不用担心切换造成的数据不同步
- 打包方便，有现成的脚手架可以用，也比较不容易出问题

##### 单页面的劣势

- 所有逻辑和业务都在一个页面上，逻辑上不是很清楚，当业务变得复杂的时候改动起来就比较麻烦
- 鸡蛋都在一个篮子里，只要一个地方出现错误，可能导致整个页面出错
- 所有代码都在一个页面，首次加载耗时较长，页面体积较大

> 只有一张 Web 页面的应用，是一种从 Web 服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css 等)仅需加载一次页面跳转：  
> 使用 js 中的 append/remove 或者 show/hide 的方式来进行页面内容的更换； 数据传递：可通过全局变量或者参数传递，进行相关数据交互

_使用场景： 适用于高度追求高度支持搜索引擎的应用_

##### 那么多页面有什么优势呢？

- 逻辑清楚，各个页面按照功能和逻辑划分，不用担心业务复杂度
- 单个页面体积较小，加载速度比较有保证
- 多页面跳转需要刷新所有资源，每个公共资源(js、css 等)需选择性重新加载
- 页面跳转：使用 window.location.href = "./index.html"进行页面间的跳转；
- 数据传递：可以使用 path?account="123"&password=""路径携带数据传递的方式，或者 localstorage、cookie 等存储方式

_使用场景： 高要求的体验度，追求界面流畅的应用_

##### 多页面当然也有劣势

- 重复代码较多
- 页面经常需要切换，切换效果取决于浏览器和网络情况，对用户体验会有一定负面影响
- 无法充分利用 vue 的路由和状态保持，在多个页面之间共享和同步数据状态会成为一个难题

---

## 前端鉴权了解过吗？

## 设计模式了解多少？

## 快速排序的思路是怎样的

---

## 对 JS 单线程的理解

##### 单线程是 JavaScript 最大的特点

_为什么不是多线程呢？提高效率不好吗？_

如果两个命令同时操作一个 DOM
一个添加内容，一个删除节点  
请问这个时候该怎么办？以哪个线程为准呢？

##### 异步的出现

js 是单线程的，只能自上而下的运行  
如果上一行运行了很长很长时间，那下面的代码就没法执行力啦，阻塞了，对用户而言，页面直接卡死啦！！这还能用吗？！

_那异步到底是如何实现的呢？_

##### event loop 事件循环

首先 js 主线程会不断循环

如果遇到同步任务，创建执行上下文，按顺序进入执行栈

如果是异步，js 当然不会一直等待它的结果，不然后面阻塞了，怎么办呢

<img src="/images/evenloop.png" width="60%">

调用栈，也叫做执行栈，它就像一个水桶一样  
js 代码按照从上至下运行，一旦需要执行的代码，会立刻放入调用栈中  
按照后进先出的原则

> 记住单线程 js 的执行逻辑  
> 调用栈 > 微任务 > 消息队列

事件列表会依次把每个事件压入到调用栈中准备执行  
如果遇到的是 setTimeout 这种异步函数，同样会压入调用栈中

只不过接下来会把异步函数中的回调函数放入消息队列  
当调用栈都执行完毕后，再回头来调取消息队列依次执行

<!--
      function func1(){    // 5、接第四步，执行func1
          console.log(1);    // 6、压入 console进调用栈，打印得到 1，出栈，
          // 7、func1 执行结束，func1 出栈
      }
      function fun2(){     // 2、执行func2
          console.log(2);   // 3、压入console进调用栈，打印得到 2，出栈
          func1();     // 4、发现函数 func1，压入调用栈中，此时 func1 在 func2的上面
          console.log(3);  // 8、func1 结束，代码继续，console.log 打印 3 出栈
          // 9、func2 执行结束，func2 出栈
      }
      func2();  // 1、发现函数 func2，压入调用栈中 -->

![avatar](/images/even1.png)

<!-- <img src="/images/even1.png" > -->

_我们再看一下带有异步的例子_

<img src="/images/even2.png" >

_更复杂一点，我们加入 promise_

<img src="/images/even3.png" >

> 事件循环 event loop 就是让 js 既是单线程，又不会阻塞下面运行的核心机制  
> 也是 js 并发模型的基础

https://juejin.im/post/5e37de90f265da3e413f6150

---

## 事件模型能介绍一下吗

## 对算法了解怎么样？常用的排序算法？

## 讲一下性能优化？具体哪些优化的收益更大一些
